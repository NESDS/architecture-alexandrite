# Архитектурное решение по кешированию

## 1. Мотивация

### Текущая проблема

**Операторы MES не могут эффективно работать:**
- Медленная загрузка дашборда с заказами (>10 секунд при 3000+ заказах)
- Фильтр по статусам и пагинация не решили проблему
- Каждое обновление страницы = запрос к БД = высокая нагрузка
- Операторам критично видеть самые новые заказы (от этого зависит вознаграждение)

**Технические причины:**
- MES БД читает тысячи записей при каждом запросе
- N+1 запросы при рендеринге списка
- Отсутствие кеширования данных
- 1 инстанс БД на запись + чтение = узкое горло

### Что даст кеширование

**Для бизнеса:**
- Операторы берут заказы в работу в 10 раз быстрее
- Производство работает эффективнее → больше заказов в день
- Снижение жалоб от операторов

**Для технических метрик:**
- Время загрузки дашборда: 10+ сек → <1 сек
- Нагрузка на MES БД: снижение read-запросов на 80%
- Latency MES API: P95 снижение с 8 сек до 500 мс

**Элементы системы для кеширования:**
1. **MES API: список заказов** (GET `/orders?status=...`) - основная проблемная точка
2. **MES API: детали заказа** (GET `/orders/{id}`) - часто запрашивается
3. **MES API: список операторов** (GET `/operators`) - редко меняется
4. **CRM API: информация о клиентах** - для разгрузки CRM БД

---

## 2. Предлагаемое решение

### 2.1 Тип кеширования: Серверное

**Выбор: Серверное кеширование на уровне MES API**

**Обоснование:**
- ✅ Данные общие для всех операторов (нет смысла кешировать на клиенте)
- ✅ Централизованное управление инвалидацией
- ✅ Снижение нагрузки на БД (критично при 1 инстансе)
- ✅ Эффективное использование памяти (1 копия данных vs N клиентов)
- ❌ Клиентское кеширование НЕ подходит: операторам нужны актуальные данные о новых заказах

**Технология: Redis Cluster**
- Master-Replica конфигурация (1 master + 1 replica для отказоустойчивости)
- Managed Redis на Yandex Cloud для простоты управления
- Размер: 4GB (достаточно для 10K+ заказов в кеше)

### 2.2 Паттерн кеширования: Cache-Aside (Lazy Loading)

**Выбор: Cache-Aside**

**Как работает:**
1. Приложение проверяет наличие данных в кеше
2. Если данные есть (cache hit) → возврат из Redis
3. Если данных нет (cache miss) → запрос к БД → запись в Redis → возврат клиенту

**Почему Cache-Aside:**
- ✅ Простота реализации и отладки
- ✅ Кеш заполняется только востребованными данными (экономия памяти)
- ✅ Приложение контролирует когда и что кешировать
- ✅ Устойчивость: если Redis недоступен, система работает (медленнее, но работает)
- ✅ Гибкость: разные TTL для разных типов данных

**Почему НЕ Write-Through:**
- ❌ Каждая запись в БД = запись в кеш (лишняя нагрузка при обновлении статуса)
- ❌ Кеш заполняется данными, которые могут не читаться
- ❌ Сложнее реализовать при распределенной системе (MES → RabbitMQ → CRM)

**Почему НЕ Refresh-Ahead:**
- ❌ Сложность предсказания какие данные будут запрошены
- ❌ Излишнее обновление кеша = нагрузка на БД
- ❌ Требует дополнительного background процесса

### 2.3 Sequence diagram

#### Сценарий 1: Чтение списка заказов

**[Случай A: Cache HIT - данные в кеше]**

```
┌──────────┐     ┌─────────┐      ┌───────┐     ┌────────┐
│Оператор  │     │MES API  │      │ Redis │     │MES DB  │
└────┬─────┘     └────┬────┘      └───┬───┘     └───┬────┘
     │                │               │             │
     │ GET /orders?status=APPROVED    │             │
     ├───────────────>│               │             │
     │                │               │             │
     │                │ GET key:      │             │
     │                │ orders:APPROVED:page1       │
     │                ├──────────────>│             │
     │                │               │             │
     │                │ [Cache HIT]   │             │
     │                │<──────────────┤             │
     │                │  JSON data    │             │
     │                │               │             │
     │  200 OK + JSON │               │             │
     │<───────────────┤               │             │
     │  (латентность: │               │             │
     │   50-100ms)    │               │             │
     │                │               │             │
```

**[Случай B: Cache MISS - данных нет в кеше]**

```
┌──────────┐     ┌─────────┐      ┌───────┐     ┌────────┐
│Оператор  │     │MES API  │      │ Redis │     │MES DB  │
└────┬─────┘     └────┬────┘      └───┬───┘     └───┬────┘
     │                │               │             │
     │ GET /orders?status=STARTED     │             │
     ├───────────────>│               │             │
     │                │               │             │
     │                │ GET key:      │             │
     │                │ orders:STARTED:page1        │
     │                ├──────────────>│             │
     │                │               │             │
     │                │ [Cache MISS]  │             │
     │                │<──────────────┤             │
     │                │  null         │             │
     │                │               │             │
     │                │ SELECT * FROM orders        │
     │                │ WHERE status='STARTED'      │
     │                │ LIMIT 50 OFFSET 0           │
     │                ├────────────────────────────>│
     │                │               │             │
     │                │<────────────────────────────┤
     │                │ Rows (50 записей)           │
     │                │               │             │
     │                │ SET key:      │             │
     │                │ orders:STARTED:page1        │
     │                │ EX 60         │             │
     │                ├──────────────>│             │
     │                │               │             │
     │                │<──────────────┤             │
     │                │     OK        │             │
     │                │               │             │
     │  200 OK + JSON │               │             │
     │<───────────────┤               │             │
     │  (латентность: │               │             │
     │   800-1500ms)  │               │             │
     │                │               │             │
```

#### Сценарий 2: Изменение статуса заказа (инвалидация кеша)

```
┌──────────┐   ┌─────────┐    ┌───────┐   ┌────────┐   ┌──────────┐
│Оператор  │   │MES API  │    │ Redis │   │MES DB  │   │RabbitMQ  │
└────┬─────┘   └────┬────┘    └───┬───┘   └───┬────┘   └────┬─────┘
     │              │             │           │             │
     │ POST /orders/123/start     │           │             │
     ├─────────────>│             │           │             │
     │              │             │           │             │
     │              │ [1. Обновление БД]      │             │
     │              │             │           │             │
     │              │ UPDATE orders           │             │
     │              │ SET status='STARTED'    │             │
     │              │ WHERE id=123            │             │
     │              ├────────────────────────>│             │
     │              │             │           │             │
     │              │<────────────────────────┤             │
     │              │ 1 row updated           │             │
     │              │             │           │             │
     │              │ [2. Инвалидация кеша]   │             │
     │              │             │           │             │
     │              │ DEL orders:APPROVED:*   │             │
     │              ├────────────>│           │             │
     │              │             │           │             │
     │              │<────────────┤           │             │
     │              │    OK       │           │             │
     │              │             │           │             │
     │              │ DEL orders:STARTED:*    │             │
     │              ├────────────>│           │             │
     │              │             │           │             │
     │              │<────────────┤           │             │
     │              │    OK       │           │             │
     │              │             │           │             │
     │              │ DEL order:123           │             │
     │              ├────────────>│           │             │
     │              │             │           │             │
     │              │<────────────┤           │             │
     │              │    OK       │           │             │
     │              │             │           │             │
     │              │ [3. Публикация события] │             │
     │              │             │           │             │
     │              │ PUBLISH status_changed  │             │
     │              │ {order_id: 123, ...}    │             │
     │              ├──────────────────────────────────────>│
     │              │             │           │             │
     │              │<──────────────────────────────────────┤
     │              │    ACK      │           │             │
     │              │             │           │             │
     │  200 OK      │             │           │             │
     │<─────────────┤             │           │             │
     │              │             │           │             │
     │              │ [4. Логирование]        │             │
     │              │             │           │             │
     │              │ [INFO] Order 123        │             │
     │              │ status: APPROVED->STARTED             │
     │              │ trace_id=abc, cache_invalidated       │
     │              │             │           │             │
```

### 2.4 Стратегия инвалидации кеша

**Выбор: Гибридная стратегия (TTL + программная инвалидация по событию)**

#### Компоненты стратегии:

**1. Временная инвалидация (TTL)**
- Список заказов: TTL = 60 секунд
- Детали заказа: TTL = 300 секунд (5 минут)
- Список операторов: TTL = 3600 секунд (1 час)

**Обоснование TTL:**
- 60 сек для списка заказов: баланс между свежестью и производительностью
- Даже если программная инвалидация не сработает (сбой), данные обновятся через минуту
- Защита от "забытых" ключей в кеше

**2. Программная инвалидация (Event-based)**

**События для инвалидации:**
- Создание заказа → удалить `orders:INITIATED:*`
- Изменение статуса → удалить `orders:{old_status}:*`, `orders:{new_status}:*`, `order:{id}`
- Назначение оператора → удалить `orders:*`, `order:{id}`
- Удаление заказа → удалить `order:{id}`

**Реализация:**
```java
// Псевдокод для MES API (Java)
@Service
public class OrderCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redis;
    
    public void invalidateOnStatusChange(Order order, String oldStatus, String newStatus) {
        // Удаляем списки со старым и новым статусом
        redis.delete(redis.keys("orders:" + oldStatus + ":*"));
        redis.delete(redis.keys("orders:" + newStatus + ":*"));
        
        // Удаляем детали заказа
        redis.delete("order:" + order.getId());
        
        // Логируем для трейсинга
        log.info("Cache invalidated for order {} status change {} -> {}, trace_id={}", 
            order.getId(), oldStatus, newStatus, MDC.get("trace_id"));
    }
}
```

**3. Инвалидация по ключу (Pattern-based)**

**Ключи кеша:**
- `orders:{status}:{page}` - список заказов (например, `orders:APPROVED:1`)
- `order:{id}` - детали заказа (например, `order:12345`)
- `operators:all` - список операторов

**Инвалидация:**
- При изменении статуса: удаляем по паттерну `orders:*` (все списки)
- При обновлении заказа: удаляем конкретный ключ `order:{id}`

#### Сравнение стратегий инвалидации

| Стратегия | Плюсы | Минусы | Применимость |
|-----------|-------|--------|--------------|
| **Только TTL** | ✅ Простота<br>✅ Не требует кода инвалидации<br>✅ Защита от stale data | ❌ Данные могут быть устаревшими до истечения TTL<br>❌ Нельзя обновить немедленно | ❌ **НЕ подходит**: операторам нужны актуальные заказы |
| **Только программная** | ✅ Мгновенное обновление<br>✅ Полный контроль | ❌ Сложность реализации<br>❌ Риск "забытых" ключей при сбоях<br>❌ Нужна синхронизация через RabbitMQ | ⚠️ Подходит, но рискованно без страховки |
| **Гибридная (TTL + программная)** | ✅ Мгновенное обновление при событии<br>✅ Страховка через TTL<br>✅ Защита от stale data<br>✅ Устойчивость к сбоям | ⚠️ Средняя сложность реализации | ✅ **ВЫБРАНА**: оптимальный баланс |
| **LRU (least recently used)** | ✅ Автоматическое управление памятью | ❌ Не гарантирует свежесть данных<br>❌ Сложно предсказать что будет удалено | ❌ НЕ подходит как основная стратегия |

#### Обработка edge cases

**1. Одновременное обновление заказа**
- Используем оптимистичные блокировки в БД (version поле)
- При конфликте: повтор операции + инвалидация кеша

**2. Сбой Redis**
- Приложение работает без кеша (fallback на БД)
- Алерт в Prometheus при недоступности Redis
- Автоматическое восстановление при доступности

**3. RabbitMQ задержка**
- TTL страхует: через 60 сек данные обновятся
- Мониторинг consumer lag (из Task3 - трейсинг)

**4. Кеш большого размера**
- Ограничение maxmemory в Redis = 4GB
- Политика eviction: allkeys-lru (удаление редко используемых)
- Мониторинг памяти Redis (из Task2 - мониторинг)

---

## 3. Дополнительная оптимизация

### 3.1 Индексы БД (работает совместно с кешем)

**Добавить индексы в MES DB:**
```sql
CREATE INDEX idx_orders_status_created 
ON orders(status, created_at DESC);

CREATE INDEX idx_orders_operator_status 
ON orders(operator_id, status) 
WHERE operator_id IS NOT NULL;

CREATE INDEX idx_orders_created 
ON orders(created_at DESC);
```

**Эффект:**
- Запросы к БД (при cache miss) выполняются в 10-20 раз быстрее
- Cache miss не будет "убивать" систему

### 3.2 Оптимизация запросов

**Использовать cursor-based pagination:**
```sql
-- Вместо OFFSET (медленно при больших offset)
SELECT * FROM orders 
WHERE status = 'APPROVED' 
AND created_at < :last_seen_timestamp
ORDER BY created_at DESC 
LIMIT 50;
```

**Эффект:**
- Стабильная производительность независимо от страницы
- Cache key: `orders:APPROVED:cursor:{timestamp}`

### 3.3 Cache warming (опционально)

**Предзагрузка популярных данных:**
- После деплоя MES API: загрузить в кеш первые страницы для каждого статуса
- Background задача: обновление каждые 30 секунд для топ-10 запросов

---

## 4. Интеграция с существующей Observability

### 4.1 Мониторинг (из Task2)

**Метрики в Prometheus:**
```
# Cache hit rate
cache_hit_rate{service="mes-api", cache_key_pattern="orders:*"} 
Target: >80%

# Cache latency
cache_operation_duration_seconds{operation="get"} 
Target: P95 <50ms

# Cache size
redis_memory_used_bytes{instance="redis-master"}
Alert: >3.5GB (87% из 4GB)

# Cache evictions
redis_evicted_keys_total
Alert: >100/min (признак нехватки памяти)
```

**Дашборд в Grafana:**
- Cache Hit Rate по типам запросов
- Latency: Redis vs БД
- Экономия запросов к БД (сколько не пошло в БД благодаря кешу)

### 4.2 Трейсинг (из Task3)

**Spans в Jaeger:**
- Операция `cache.get` с атрибутами: `cache_key`, `hit/miss`, `duration_ms`
- Операция `cache.invalidate` с атрибутами: `pattern`, `keys_deleted`
- Связь: HTTP span → cache span → DB span (при miss)

**Drill-down:**
- От медленного запроса в Grafana → к трейсу в Jaeger → видим cache miss → видим медленный DB запрос

### 4.3 Логирование (из Task4)

**Логи в ELK:**
```json
{
  "timestamp": "2025-10-26T10:15:30.123Z",
  "service": "mes-api",
  "level": "INFO",
  "trace_id": "abc123",
  "event": "cache_operation",
  "cache_key": "orders:APPROVED:1",
  "operation": "get",
  "result": "hit",
  "duration_ms": 45
}

{
  "timestamp": "2025-10-26T10:16:10.456Z",
  "service": "mes-api",
  "level": "INFO",
  "trace_id": "def456",
  "event": "cache_invalidation",
  "order_id": "12345",
  "reason": "status_changed",
  "patterns": ["orders:APPROVED:*", "orders:STARTED:*", "order:12345"],
  "keys_deleted": 15
}
```

### 4.4 Алертинг (интеграция с Alertmanager)

**Критичные алерты:**
- Redis недоступен >5 минут → PagerDuty
- Cache hit rate <50% за 10 минут → Slack (возможно проблема с инвалидацией)
- Redis память >90% → PagerDuty (риск eviction важных данных)

**Предупреждающие алерты:**
- Cache hit rate <70% за 30 минут → Slack
- Высокая latency Redis (P95 >100ms) → Slack

---

## 5. План внедрения

### Этап 1: Подготовка (1 неделя)
- Развернуть Redis Cluster (Managed Yandex Cloud)
- Настроить мониторинг Redis (Prometheus + Grafana)
- Добавить индексы в MES БД

### Этап 2: Разработка (2 недели)
- Интегрировать Redis клиент в MES API (C# StackExchange.Redis)
- Реализовать Cache-Aside логику
- Добавить программную инвалидацию
- Написать юнит-тесты для кеш-логики

### Этап 3: Тестирование (1 неделя)
- Load testing: симуляция 100 операторов
- Проверка инвалидации при изменении статусов
- Проверка fallback при недоступности Redis
- E2E тесты в release окружении

### Этап 4: Production (1 неделя)
- Деплой на 50% трафика (canary deployment)
- Мониторинг метрик: hit rate, latency, errors
- Полный rollout при успехе
- Дежурство команды первые 48 часов

**Ресурсы:** 1 C# dev (full-time), 1 DevOps (part-time), 1 QA (тестирование)

**Итого:** 5 недель полного внедрения

---

## 6. Ожидаемые результаты

### Технические метрики

| Метрика | До кеширования | После кеширования | Улучшение |
|---------|---------------|-------------------|-----------|
| Latency дашборда (P95) | 8-10 сек | <1 сек | **10x** |
| Read нагрузка на БД | 100% | 20% | **-80%** |
| RPS MES API | 50 req/s | 250 req/s | **5x** |
| Cache hit rate | - | 80%+ | - |
| Время взятия заказа | 12 сек | 2 сек | **6x** |

### Бизнес-метрики

- **Производительность операторов:** +30% заказов в день (быстрее находят и берут заказы)
- **Удовлетворенность операторов:** снижение жалоб на 90%
- **Масштабируемость:** готовность к росту +100 заказов/месяц без деградации
- **Экономия инфраструктуры:** отложена необходимость масштабирования БД на 6+ месяцев (~$500/месяц)

### ROI (Return on Investment)

**Затраты:**
- Redis Managed (4GB): ~$50/месяц
- Разработка: 5 недель * $800/неделя = $4000 (one-time)
- Поддержка: ~2 часа/месяц

**Выгоды:**
- Отложенное масштабирование БД: $500/месяц экономии
- Рост производительности операторов: +30% заказов = +$X выручки
- Снижение MTTR инцидентов: экономия времени команды

**Окупаемость: 2-3 месяца**

---

## Заключение

Внедрение кеширования с использованием **Redis + Cache-Aside паттерна + гибридной инвалидации (TTL + event-based)** решает критическую проблему медленной работы MES дашборда. 

Решение интегрируется с существующей системой observability (мониторинг, трейсинг, логирование) и обеспечивает:
- ✅ 10-кратное улучшение производительности
- ✅ Снижение нагрузки на БД на 80%
- ✅ Готовность к масштабированию
- ✅ Устойчивость к сбоям (fallback на БД)
- ✅ Полная наблюдаемость (метрики, трейсы, логи)

