# Выбор и настройка мониторинга в системе

## 1. Мотивация

### Текущая ситуация и проблемы
После открытия B2B API компания столкнулась с критическими проблемами:
- Клиенты не получают заказы, сроки нарушаются (месяцы вместо 3 недель)
- Потеря крупных B2B контрактов
- Рост жалоб от B2C клиентов
- Операторы не могут эффективно работать из-за медленной загрузки дашборда MES

**Корень проблемы** — отсутствие наблюдаемости системы. Мы не видим:
- Где "застревают" заказы в цепочке Shop → MES → CRM
- Как проходят сообщения через RabbitMQ
- Реальную производительность каждого компонента
- Проблемы до того, как о них сообщают клиенты

### Что даст мониторинг

**Для бизнеса:**
- Раннее обнаружение проблем → сохранение контрактов и репутации
- Выполнение обещанных SLA по срокам
- Обоснованные решения о масштабировании инфраструктуры
- Возможность обрабатывать больший объем заказов

**Для команды:**
- Сокращение времени диагностики проблем с часов до минут
- Проактивные алерты вместо реактивного тушения пожаров
- Понимание реальных узких мест для целевой оптимизации
- Прозрачность нагрузки на все компоненты системы

---

## 2. Выбор подхода к мониторингу

Для разных частей системы будем использовать разные подходы:

### 2.1 RED метод - для всех API (Shop API, CRM API, MES API)

**RED = Rate, Errors, Duration**

Выбран для API, так как это request-driven сервисы, где важно:
- **Rate (запросы в секунду)**: понимать нагрузку и тренды
- **Errors (количество ошибок)**: быстро обнаруживать деградацию
- **Duration (время ответа)**: отслеживать производительность с точки зрения пользователя

**Применение:**
- Shop API: отслеживание B2C трафика (создание заказов, загрузка моделей)
- CRM API: мониторинг работы менеджеров по продажам
- MES API: отслеживание B2B API + работы операторов

### 2.2 USE метод - для инфраструктурных компонентов

**USE = Utilization, Saturation, Errors**

Выбран для ресурсов (CPU, память, БД, очереди), так как важно:
- **Utilization (использование)**: насколько загружен ресурс в среднем
- **Saturation (насыщенность)**: есть ли очередь/переполнение
- **Errors (ошибки)**: сбои на уровне ресурсов

**Применение:**
- EC2 инстансы (CPU, память)
- База данных (connections, memory, disk I/O)
- RabbitMQ (длина очередей, consumer lag)
- S3 Storage (размер, throughput)

### 2.3 Четыре золотых сигнала - для критичного потока заказов

**Latency, Traffic, Errors, Saturation**

Выбран для end-to-end мониторинга потока заказов через все системы:
- **Latency**: сколько времени заказ проходит от создания до PRICE_CALCULATED
- **Traffic**: количество новых заказов в час (B2C + B2B)
- **Errors**: сколько заказов "застряло" или ушло в failed state
- **Saturation**: сколько заказов ожидает обработки в очередях

---

## 3. Метрики для отслеживания

### 3.1 RabbitMQ метрики

#### ✅ Number of dead-letter-exchange letters in RabbitMQ
**Зачем**: Критично для обнаружения потери заказов. Показывает сообщения, которые не смогли обработаться.

**Ярлыки**: 
- `queue_name` (orders, status_updates, price_calculation)
- `reason` (timeout, error, rejected)

---

#### ✅ Number of messages in flight in RabbitMQ
**Зачем**: Показывает количество сообщений в обработке. Высокое значение сигнализирует о медленной обработке или зависших consumer'ах.

**Ярлыки**: 
- `queue_name`
- `consumer_tag`

---

### 3.2 API Request метрики (RED)

#### ✅ Number of requests (RPS) for internet shop API
**Зачем**: Понимание B2C нагрузки, обнаружение аномалий (всплески, провалы).

**Ярлыки**: `method`, `endpoint`, `status_code`

---

#### ✅ Number of requests (RPS) for CRM API
**Зачем**: Мониторинг активности менеджеров, обнаружение проблем доступности.

**Ярлыки**: `method`, `endpoint`, `status_code`

---

#### ✅ Number of requests (RPS) for MES API
**Зачем**: Критично для отслеживания B2B API нагрузки и активности операторов. Внезапное падение = проблема.

**Ярлыки**: `method`, `endpoint`, `status_code`, `client_type`

---

#### ✅ Number of requests (RPS) per user for MES API
**Зачем**: Обнаружение аномального поведения B2B клиентов, превышение квот.

**Ярлыки**: `api_key`, `endpoint`

---

### 3.3 Инфраструктурные метрики (USE)

#### ✅ CPU % for shop API / CRM API / MES API
**Зачем**: Понимание загрузки инстансов, планирование масштабирования. Для MES особенно важно - высокая CPU означает медленный расчет стоимости.

**Ярлыки**: `instance_id`, `environment`

---

#### ✅ Memory Utilisation for shop API / CRM API / MES API
**Зачем**: Обнаружение утечек памяти, планирование размера инстансов, предотвращение OOM.

**Ярлыки**: `instance_id`, `memory_type` (heap/non_heap для Java, managed/unmanaged для C#)

---

#### ✅ Memory Utilisation for shop db / MES db instance
**Зачем**: БД кеширует данные в памяти. Нехватка памяти приводит к медленным запросам.

**Ярлыки**: `database_name`, `memory_type`

---

#### ✅ Number of connections for shop db / MES db instance
**Зачем**: PostgreSQL имеет лимит соединений. Превышение приводит к ошибкам "connection refused".

**Ярлыки**: `database_name`, `state` (active, idle, idle_in_transaction)

---

### 3.4 Latency метрики (RED Duration)

#### ✅ Response time (latency) for shop API / CRM API / MES API
**Зачем**: 
- Shop API: влияет на UX, медленные ответы → брошенные корзины
- CRM API: влияет на скорость работы менеджеров
- MES API: критично для B2B клиентов и операторов (текущая проблема с дашбордом!)

**Ярлыки**: `endpoint`, `method`, `percentile` (p50, p95, p99), `client_type` (для MES)

---

### 3.5 Storage метрики

#### ✅ Size of S3 storage
**Зачем**: Планирование бюджета и отслеживание аномального роста (загрузка лишних файлов).

**Ярлыки**: `bucket_name`, `file_type`

---

#### ✅ Size of shop db / MES db instance
**Зачем**: Планирование масштабирования БД, обнаружение неконтролируемого роста.

**Ярлыки**: `database_name`

---

### 3.6 Error метрики (RED Errors)

#### ✅ Number of HTTP 200 for shop API / CRM API / MES API
**Зачем**: Базовая метрика успешности. Используется для расчета error rate = (errors / total requests).

**Ярлыки**: `endpoint`, `method`, `client_type` (для MES)

---

#### ✅ Number of HTTP 500 for shop API / CRM API / MES API
**Зачем**: Критично! 5xx ошибки означают проблемы на сервере, что приводит к потере заказов. Особенно важно для MES B2B API.

**Ярлыки**: `endpoint`, `error_type`, `client_type` (для MES)

---

### 3.7 Throughput метрики

#### ✅ Kb transferred (received) for shop API / MES API
**Зачем**: Мониторинг входящего трафика. Важно для `/upload` (большие 3D модели) и B2B API.

**Ярлыки**: `endpoint`, `client_type` (для MES)

---

#### ✅ Kb provided (sent) for shop API / MES API
**Зачем**: Мониторинг исходящего трафика. Особенно важно для MES `/dashboard` (большие списки заказов).

**Ярлыки**: `endpoint`

---

### 3.8 Session метрики

#### ✅ Number of simultaneous sessions for shop API / CRM API / MES API
**Зачем**: Понимание количества активных пользователей, планирование capacity.

**Ярлыки**: `user_type` / `role`

---

### 3.9 Дополнительные бизнес-метрики

#### ✅ Order Processing Time (кастомная метрика)
**Зачем**: Отслеживание SLA (3 недели). Время от SUBMITTED до MANUFACTURING_STARTED.

**Ярлыки**: `order_type`, `complexity`

---

#### ✅ Orders Stuck in Status (кастомная метрика)
**Зачем**: Обнаружение "застрявших" заказов (текущая проблема!).

**Ярлыки**: `status`, `stuck_duration`

---

#### ✅ Price Calculation Duration (кастомная метрика)
**Зачем**: Мониторинг текущей проблемы расчета стоимости (2-30 минут).

**Ярлыки**: `complexity`, `client_type`

---

#### ✅ RabbitMQ Consumer Lag (кастомная метрика)
**Зачем**: Показывает отставание consumer'ов, критично для выявления узких мест.

**Ярлыки**: `queue_name`, `consumer_group`

---

### 3.10 Redis Cache метрики (USE)

#### ✅ Redis Memory Utilisation
**Зачем**: Критично для кеширования MES дашборда (Task5). Нехватка памяти приводит к eviction важных данных и деградации производительности.

**Ярлыки**: `instance` (master/replica), `memory_type` (used/peak/fragmentation)

---

#### ✅ Redis Cache Hit Rate
**Зачем**: Показывает эффективность кеширования. Низкий hit rate означает проблемы с инвалидацией или недостаточный TTL.

**Ярлыки**: `cache_key_pattern`, `service` (mes-api, crm-api)

---

#### ✅ Redis Evicted Keys
**Зачем**: Количество ключей, удаленных из-за нехватки памяти. Высокие значения = нужно увеличивать размер кеша.

**Ярлыки**: `instance`, `eviction_policy`

---

#### ✅ Redis Operations Latency
**Зачем**: Время выполнения операций GET/SET. Медленный Redis = проблемы с сетью или перегрузка.

**Ярлыки**: `operation` (get/set/del), `percentile` (p50/p95/p99)

---

#### ✅ Redis Connected Clients
**Зачем**: Мониторинг количества подключений. Превышение лимита = отказ в обслуживании.

**Ярлыки**: `instance`, `client_type` (normal/replica)

---

## 4. План действий

### Этап 1: Подготовка инфраструктуры мониторинга (1-2 недели)

**Создать инстанс Prometheus** для хранения метрик в time-series формате. Использовать Managed Prometheus на Yandex Cloud или self-hosted решение с retention 30 дней.

**Развернуть Grafana** для визуализации метрик и создания дашбордов. Настроить интеграцию с Prometheus.

**Настроить Alertmanager** для уведомлений: Slack для команды, PagerDuty для критичных алертов, Email для некритичных.

---

### Этап 2: Инструментация приложений (2-3 недели)

**Добавить Prometheus клиенты в все API**:
- Shop API и CRM API (Java): интегрировать `micrometer-registry-prometheus`, expose `/actuator/prometheus`
- MES API (C#): интегрировать `prometheus-net.AspNetCore`, expose `/metrics`
- Экспортировать базовые метрики: HTTP requests, latency, errors, CPU, memory

**Настроить экспорт метрик инфраструктуры**:
- RabbitMQ: подключить `rabbitmq_exporter` для метрик очередей
- PostgreSQL: подключить `postgres_exporter` для обеих БД (shop_db, mes_db)
- Redis: подключить `redis_exporter` для метрик кеша (будет использоваться в Task5)

**Добавить кастомные бизнес-метрики**:
- Order processing time
- Orders stuck in status
- Price calculation duration
- RabbitMQ consumer lag

---

### Этап 3: Создание дашбордов (1 неделя)

**Создать базовые дашборды в Grafana**:
- **System Overview**: общее здоровье системы (RPS, errors, latency, CPU/Memory)
- **MES Performance**: детальный мониторинг проблемной области (price calculation, dashboard load time)
- **Business Metrics**: бизнес-метрики для менеджмента (SLA, застрявшие заказы)
- **Infrastructure**: метрики железа, БД, Redis, RabbitMQ

---

### Этап 4: Настройка алертов (1 неделя)

**Критичные алерты** (PagerDuty): API down, RabbitMQ DLQ messages, DB connections exhausted, застрявшие заказы, Redis недоступен, Redis memory >95%.

**Предупреждающие алерты** (Slack): высокая CPU/Memory, медленные API, consumer lag, Redis hit rate <70%.

**Capacity planning алерты** (Email): рост storage, trends нагрузки.

---

### Этап 5: Тестирование и внедрение (2-3 недели)

**Dev окружение**: тестирование метрик и алертов, load testing.

**Release окружение**: мониторинг в течение недели, настройка порогов.

**Production**: постепенный rollout, дежурство команды первые 24 часа.

**Обучение команды**: runbook для алертов, воркшоп по Grafana.

---

**Итого**: 6-8 недель полного внедрения

**Ресурсы**: 1 DevOps (full-time), 2 Java dev, 1 C# dev (part-time), 1 QA

---

## 5. Дополнительно: Показатели насыщенности

### 5.1 Пороговые значения

| Метрика | Warning | Critical | Обоснование |
|---------|---------|----------|-------------|
| **RabbitMQ Queue** | > 500 | > 2000 | Норма 10-50. При 2000 задержка 30+ минут |
| **DB Connections** | > 70% | > 90% | PostgreSQL лимит фиксирован. При 100% ошибки подключения |
| **MES API Latency** | > 3s | > 10s | Текущая проблема. 10s = система "сломана" для операторов |
| **CPU** | > 70% | > 90% | При 90% latency растет экспоненциально |
| **Memory** | > 80% | > 95% | При 95% риск OOM kill |
| **Disk Space** | > 70% | > 90% | БД может упасть при 100% |
| **Redis Memory** | > 3.5GB (87%) | > 3.8GB (95%) | Кеш 4GB. При 95% начинается eviction важных данных |
| **Redis Hit Rate** | < 70% | < 50% | Норма >80%. Низкий rate = проблемы с кешированием |

### 5.2 Реакция системы при превышении

**Warning уровень** (Slack alert):
- Дежурный инженер берет в работу (15 мин)
- Диагностика: проверка логов, метрик
- Действия: оптимизация, подготовка масштабирования

**Critical уровень** (PagerDuty звонилка):
- Acknowledge за 5 мин, mitigation за 30 мин
- Автоматическое создание тикета в Jira
- Действия: автоматический запуск инстансов, kill idle connections, cleanup scripts, рестарт приложений
- Redis: увеличение памяти, принудительная очистка старых ключей, fallback на БД
- При необходимости: включить rate limiting, агрессивное кеширование

**Эскалация** (Email + звонки):
- Если не resolved за 1 час → уведомление Тимлид + PM
- Возможен rollback или maintenance mode

### 5.3 Превентивные меры

- **Capacity Planning Review** (еженедельно): планирование до достижения warning
- **Load Testing** (перед релизом): симуляция 2x нагрузки
- **Chaos Engineering** (ежемесячно): проверка системы восстановления

